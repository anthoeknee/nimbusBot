import { safeJsonParse, safeJsonStringify } from "../client";
import { EntityId } from "../types";
import { logger } from "../../../utils/logger";
import {
  MemoryRow,
  CreateMemoryInput,
  UpdateMemoryInput,
  MemoryRecord,
  MemorySearchOptions,
  MemorySearchResult,
  MemoryAnalytics,
  ConsolidationCandidate,
  MemoryRelationship,
  DatabaseOperationResult,
} from "../../../types/memory";
import { db } from "../client";

/**
 * Enhanced Memory Repository - Comprehensive implementation with vector similarity search,
 * analytics, relationships, and advanced memory management features
 */
export class EnhancedMemoryRepository {
  private readonly table = "memories";

  // ============================================================================
  // BASIC CRUD OPERATIONS (Enhanced from BaseRepository)
  // ============================================================================

  async findByUser(userId: EntityId): Promise<MemoryRecord[]> {
    const stmt = db.prepare(`SELECT * FROM memories WHERE userId = ?`);
    const rows = stmt.all(userId) as MemoryRow[];
    return rows.map((row) => this.parseMemoryRow(row));
  }

  async findByGuild(guildId: EntityId): Promise<MemoryRecord[]> {
    const stmt = db.prepare(`SELECT * FROM memories WHERE guildId = ?`);
    const rows = stmt.all(guildId) as MemoryRow[];
    return rows.map((row) => this.parseMemoryRow(row));
  }

  async findByIdParsed(id: EntityId): Promise<MemoryRecord | null> {
    const stmt = db.prepare(`SELECT * FROM memories WHERE id = ?`);
    const row = stmt.get(id) as MemoryRow | undefined;
    return row ? this.parseMemoryRow(row) : null;
  }

  /**
   * Parse a raw database row into a MemoryRecord with proper type conversion
   */
  private parseMemoryRow(row: MemoryRow): MemoryRecord {
    const embedding = safeJsonParse<number[]>(row.embedding) || [];
    const tags = safeJsonParse<string[]>(row.tags) || [];
    const metadata = safeJsonParse<Record<string, any>>(row.metadata) || {};

    return {
      id: row.id.toString(),
      content: row.content,
      embedding,
      userId: row.userId || undefined,
      guildId: row.guildId || undefined,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
      lastAccessedAt: new Date(row.lastAccessedAt),
      accessCount: row.accessCount,
      importance: row.importance,
      tags,
      metadata,
    };
  }

  // ============================================================================
  // ENHANCED CREATION WITH EMBEDDING SUPPORT
  // ============================================================================

  async createWithEmbedding(
    content: string,
    embedding: number[],
    userId?: EntityId,
    guildId?: EntityId,
    options?: {
      importance?: number;
      tags?: string[];
      metadata?: Record<string, any>;
    }
  ): Promise<MemoryRecord> {
    try {
      const now = new Date().toISOString();
      const createData: CreateMemoryInput = {
        content,
        embedding,
        userId,
        guildId,
        importance: options?.importance || 5,
        tags: options?.tags || [],
        metadata: {
          ...options?.metadata,
          createdBy: "enhanced_repository",
          autoGenerated: false,
          contentLength: content.length,
        },
        accessCount: 0,
        lastAccessedAt: now,
        createdAt: now,
        updatedAt: now,
      };
      const stmt = db.prepare(
        `INSERT INTO memories (content, embedding, userId, guildId, importance, tags, metadata, accessCount, lastAccessedAt, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING *`
      );
      const row = stmt.get(
        createData.content,
        safeJsonStringify(createData.embedding),
        createData.userId ?? null,
        createData.guildId ?? null,
        createData.importance,
        safeJsonStringify(createData.tags),
        safeJsonStringify(createData.metadata),
        createData.accessCount,
        createData.lastAccessedAt,
        createData.createdAt,
        createData.updatedAt
      ) as MemoryRow;
      const memory = this.parseMemoryRow(row);
      logger.debug("Enhanced memory created", {
        memoryId: memory.id,
        importance: memory.importance,
        tagsCount: memory.tags.length,
        contentLength: content.length,
      });
      return memory;
    } catch (error) {
      logger.error("Failed to create memory with embedding:", error);
      throw new Error("Enhanced memory creation failed");
    }
  }

  // ============================================================================
  // VECTOR SIMILARITY SEARCH
  // ============================================================================

  async findSimilar(
    queryEmbedding: number[],
    options: MemorySearchOptions = {}
  ): Promise<MemorySearchResult[]> {
    try {
      const {
        userId,
        guildId,
        topK = 10,
        minSimilarity = 0,
        tags = [],
        importanceThreshold = 0,
      } = options;
      let whereClause = "WHERE 1=1";
      const params: any[] = [];
      if (userId !== undefined) {
        whereClause += " AND userId = ?";
        params.push(userId);
      }
      if (guildId !== undefined) {
        whereClause += " AND guildId = ?";
        params.push(guildId);
      }
      if (importanceThreshold > 0) {
        whereClause += " AND importance >= ?";
        params.push(importanceThreshold);
      }
      if (tags.length > 0) {
        const tagConditions = tags.map(() => "tags LIKE ?").join(" OR ");
        whereClause += ` AND (${tagConditions})`;
        tags.forEach((tag) => params.push(`%\"${tag}\"%`));
      }
      const stmt = db.prepare(`
        SELECT id, content, embedding, userId, guildId, createdAt, updatedAt,
               lastAccessedAt, accessCount, importance, tags, metadata
        FROM memories
        ${whereClause}
        ORDER BY lastAccessedAt DESC
        LIMIT ?
      `);
      params.push(topK * 2);
      const rows = stmt.all(...params) as MemoryRow[];
      const results: MemorySearchResult[] = [];
      for (const row of rows) {
        const embedding = safeJsonParse<number[]>(row.embedding);
        if (!embedding) continue;
        if (embedding.length !== queryEmbedding.length) {
          logger.warn(
            `Skipping memory ${row.id} due to embedding dimension mismatch: stored=${embedding.length}, query=${queryEmbedding.length}`
          );
          continue;
        }
        logger.debug(
          `Comparing embeddings - Query: ${queryEmbedding.length}D, Stored: ${embedding.length}D (Memory ID: ${row.id})`
        );
        const similarity = this.calculateCosineSimilarity(
          queryEmbedding,
          embedding
        );
        if (similarity >= minSimilarity) {
          results.push({
            data: this.parseMemoryRow(row),
            similarity,
          });
        }
      }
      results.sort((a, b) => b.similarity - a.similarity);
      return results.slice(0, topK);
    } catch (error) {
      logger.error("Failed to find similar memories:", error);
      throw new Error("Memory similarity search failed");
    }
  }

  /**
   * Calculate cosine similarity between two vectors
   */
  private calculateCosineSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) {
      logger.error(
        `Embedding dimension mismatch: Query embedding has ${vecA.length} dimensions, stored embedding has ${vecB.length} dimensions`
      );
      throw new Error("Vectors must have the same length");
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  // ============================================================================
  // MEMORY ANALYTICS
  // ============================================================================

  async getAnalytics(): Promise<MemoryAnalytics> {
    try {
      const totalStmt = db.prepare("SELECT COUNT(*) as count FROM memories");
      const totalResult = totalStmt.get() as { count: number };
      const totalMemories = totalResult?.count || 0;

      const typeStmt = db.prepare(`
        SELECT
          CASE
            WHEN userId IS NOT NULL THEN 'user'
            WHEN guildId IS NOT NULL THEN 'guild'
            ELSE 'system'
          END as type,
          COUNT(*) as count
        FROM memories
        GROUP BY type
      `);
      const typeResults = typeStmt.all() as Array<{
        type: string;
        count: number;
      }>;
      const memoryByType = typeResults.reduce(
        (acc, row) => {
          acc[row.type] = row.count;
          return acc;
        },
        {} as Record<string, number>
      );

      const importanceStmt = db.prepare(
        "SELECT AVG(importance) as avg FROM memories"
      );
      const importanceResult = importanceStmt.get() as { avg: number };
      const averageImportance = importanceResult?.avg || 0;

      const activityStmt = db.prepare(`
        SELECT COUNT(*) as count
        FROM memories
        WHERE lastAccessedAt > datetime('now', '-7 days')
      `);
      const activityResult = activityStmt.get() as { count: number };
      const recentActivity = activityResult?.count || 0;

      // Get top tags
      const tagsStmt = db.prepare("SELECT tags FROM memories");
      const tagRows = tagsStmt.all() as Array<{ tags: string }>;
      const tagCounts = new Map<string, number>();

      for (const row of tagRows) {
        const tags = safeJsonParse<string[]>(row.tags) || [];
        for (const tag of tags) {
          tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
        }
      }

      const topTags = Array.from(tagCounts.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([tag, count]) => ({ tag, count }));

      // Memory distribution analysis
      const importanceDistStmt = db.prepare(`
        SELECT
          CASE
            WHEN importance >= 8 THEN 'high'
            WHEN importance >= 5 THEN 'medium'
            ELSE 'low'
          END as level,
          COUNT(*) as count
        FROM memories
        GROUP BY level
      `);
      const importanceDistResults = importanceDistStmt.all() as Array<{
        level: string;
        count: number;
      }>;
      const byImportance = importanceDistResults.reduce(
        (acc, row) => {
          acc[row.level] = row.count;
          return acc;
        },
        {} as Record<string, number>
      );

      const ageDistStmt = db.prepare(`
        SELECT
          CASE
            WHEN createdAt > datetime('now', '-1 day') THEN 'recent'
            WHEN createdAt > datetime('now', '-7 days') THEN 'week'
            WHEN createdAt > datetime('now', '-30 days') THEN 'month'
            ELSE 'old'
          END as age,
          COUNT(*) as count
        FROM memories
        GROUP BY age
      `);
      const ageDistResults = ageDistStmt.all() as Array<{
        age: string;
        count: number;
      }>;
      const byAge = ageDistResults.reduce(
        (acc, row) => {
          acc[row.age] = row.count;
          return acc;
        },
        {} as Record<string, number>
      );

      const accessDistStmt = db.prepare(`
        SELECT
          CASE
            WHEN accessCount >= 10 THEN 'frequent'
            WHEN accessCount >= 3 THEN 'moderate'
            WHEN accessCount >= 1 THEN 'occasional'
            ELSE 'unused'
          END as access_level,
          COUNT(*) as count
        FROM memories
        GROUP BY access_level
      `);
      const accessDistResults = accessDistStmt.all() as Array<{
        access_level: string;
        count: number;
      }>;
      const byAccess = accessDistResults.reduce(
        (acc, row) => {
          acc[row.access_level] = row.count;
          return acc;
        },
        {} as Record<string, number>
      );

      // Tool-driven analytics
      const toolDrivenStmt = db.prepare(`
        SELECT COUNT(*) as count
        FROM memories
        WHERE metadata LIKE '%"toolDrivenMode":true%'
      `);
      const toolDrivenResult = toolDrivenStmt.get() as { count: number };
      const toolDrivenMemories = toolDrivenResult?.count || 0;

      const categoryStmt = db.prepare(`
        SELECT
          json_extract(metadata, '$.category') as category,
          COUNT(*) as count
        FROM memories
        WHERE json_extract(metadata, '$.category') IS NOT NULL
        GROUP BY category
        ORDER BY count DESC
        LIMIT 10
      `);
      const categoryResults = categoryStmt.all() as Array<{
        category: string;
        count: number;
      }>;
      const categoryDistribution = categoryResults.reduce(
        (acc, row) => {
          if (row.category) {
            acc[row.category] = row.count;
          }
          return acc;
        },
        {} as Record<string, number>
      );

      return {
        totalMemories,
        memoryByType,
        averageImportance,
        recentActivity,
        topTags,
        memoryDistribution: {
          byImportance,
          byAge,
          byAccess,
        },
        toolDrivenAnalytics: {
          toolDrivenMemories,
          automaticMemories: totalMemories - toolDrivenMemories,
          categoryDistribution,
        },
      };
    } catch (error) {
      logger.error("Failed to get memory analytics:", error);
      throw new Error("Memory analytics failed");
    }
  }

  // ============================================================================
  // MEMORY RELATIONSHIPS
  // ============================================================================

  async createRelationship(
    sourceMemoryId: string,
    targetMemoryId: string,
    relationshipType: string,
    strength: number = 1.0,
    metadata: Record<string, any> = {}
  ): Promise<MemoryRelationship> {
    try {
      const now = new Date().toISOString();
      const relationshipData = {
        sourceMemoryId,
        targetMemoryId,
        relationshipType,
        strength,
        createdAt: now,
        metadata: safeJsonStringify(metadata),
      };

      const stmt = db.prepare(`
        INSERT INTO memory_relationships (
          sourceMemoryId, targetMemoryId, relationshipType, strength, createdAt, metadata
        ) VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(sourceMemoryId, targetMemoryId, relationshipType)
        DO UPDATE SET strength = ?, metadata = ?
      `);

      const result = stmt.run(
        relationshipData.sourceMemoryId,
        relationshipData.targetMemoryId,
        relationshipData.relationshipType,
        relationshipData.strength,
        relationshipData.createdAt,
        relationshipData.metadata,
        relationshipData.strength,
        relationshipData.metadata
      );

      return {
        id:
          result.lastInsertRowid?.toString() ||
          `${sourceMemoryId}-${targetMemoryId}`,
        sourceMemoryId,
        targetMemoryId,
        relationshipType,
        strength,
        createdAt: new Date(now),
        metadata,
      };
    } catch (error) {
      logger.error("Failed to create memory relationship:", error);
      throw new Error("Memory relationship creation failed");
    }
  }

  async getRelationships(memoryId: string): Promise<MemoryRelationship[]> {
    try {
      const stmt = db.prepare(`
        SELECT sourceMemoryId, targetMemoryId, relationshipType, strength, createdAt, metadata
        FROM memory_relationships
        WHERE sourceMemoryId = ? OR targetMemoryId = ?
      `);

      const rows = stmt.all(memoryId, memoryId) as Array<{
        sourceMemoryId: string;
        targetMemoryId: string;
        relationshipType: string;
        strength: number;
        createdAt: string;
        metadata: string;
      }>;

      return rows.map((row) => ({
        id: `${row.sourceMemoryId}-${row.targetMemoryId}`,
        sourceMemoryId: row.sourceMemoryId,
        targetMemoryId: row.targetMemoryId,
        relationshipType: row.relationshipType,
        strength: row.strength,
        createdAt: new Date(row.createdAt),
        metadata: safeJsonParse(row.metadata) || {},
      }));
    } catch (error) {
      logger.error("Failed to get memory relationships:", error);
      throw new Error("Memory relationship retrieval failed");
    }
  }

  // ============================================================================
  // ACCESS PATTERN TRACKING
  // ============================================================================

  async updateAccess(memoryId: string): Promise<void> {
    try {
      const stmt = db.prepare(`
        UPDATE memories
        SET accessCount = accessCount + 1, lastAccessedAt = CURRENT_TIMESTAMP
        WHERE id = ?
      `);

      stmt.run(memoryId);
    } catch (error) {
      logger.error(`Failed to update access for memory ${memoryId}:`, error);
      throw new Error("Memory access update failed");
    }
  }

  // ============================================================================
  // MEMORY DECAY AND CLEANUP
  // ============================================================================

  async decayScores(decayFactor: number): Promise<void> {
    try {
      const stmt = db.prepare(`
        UPDATE memories
        SET importance = importance * ?
        WHERE importance > 1
      `);

      stmt.run(decayFactor);
      logger.debug(`Applied decay factor ${decayFactor} to memory scores`);
    } catch (error) {
      logger.error("Failed to decay memory scores:", error);
      throw new Error("Memory decay failed");
    }
  }

  async deleteOldMemories(
    maxAge: number,
    minImportance: number = 1
  ): Promise<number> {
    try {
      const stmt = db.prepare(`
        DELETE FROM memories
        WHERE createdAt < datetime('now', '-${maxAge} days')
        AND importance < ?
        AND accessCount = 0
      `);

      const result = stmt.run(minImportance);
      return result.changes;
    } catch (error) {
      logger.error("Failed to delete old memories:", error);
      throw new Error("Memory deletion failed");
    }
  }

  // ============================================================================
  // CONSOLIDATION
  // ============================================================================

  async findConsolidationCandidates(
    similarityThreshold: number
  ): Promise<ConsolidationCandidate[][]> {
    try {
      const stmt = db.prepare(`
        SELECT id, content, embedding, createdAt, accessCount
        FROM memories
        WHERE accessCount > 0
        ORDER BY createdAt DESC
        LIMIT 1000
      `);

      const memories = stmt.all() as Array<{
        id: EntityId;
        content: string;
        embedding: string;
        createdAt: string;
        accessCount: number;
      }>;

      const candidates: ConsolidationCandidate[][] = [];
      const processed = new Set<string>();

      for (let i = 0; i < memories.length; i++) {
        const memoryId = memories[i].id.toString();
        if (processed.has(memoryId)) continue;

        const embedding = safeJsonParse<number[]>(memories[i].embedding);
        if (!embedding) continue;

        const group: ConsolidationCandidate[] = [
          {
            id: memoryId,
            content: memories[i].content,
            embedding,
            similarity: 1.0,
            createdAt: new Date(memories[i].createdAt),
            accessCount: memories[i].accessCount,
          },
        ];

        processed.add(memoryId);

        for (let j = i + 1; j < memories.length; j++) {
          const otherMemoryId = memories[j].id.toString();
          if (processed.has(otherMemoryId)) continue;

          const otherEmbedding = safeJsonParse<number[]>(memories[j].embedding);
          if (!otherEmbedding) continue;

          const similarity = this.calculateCosineSimilarity(
            embedding,
            otherEmbedding
          );

          if (similarity >= similarityThreshold) {
            group.push({
              id: otherMemoryId,
              content: memories[j].content,
              embedding: otherEmbedding,
              similarity,
              createdAt: new Date(memories[j].createdAt),
              accessCount: memories[j].accessCount,
            });
            processed.add(otherMemoryId);
          }
        }

        if (group.length > 1) {
          candidates.push(group);
        }
      }

      return candidates;
    } catch (error) {
      logger.error("Failed to find consolidation candidates:", error);
      throw new Error("Consolidation candidate search failed");
    }
  }

  // ============================================================================
  // ENHANCED CREATE/UPDATE WITH SERIALIZATION
  // ============================================================================

  async create(data: CreateMemoryInput): Promise<MemoryRow> {
    try {
      const serializedData = {
        ...data,
        embedding: safeJsonStringify(data.embedding),
        tags: safeJsonStringify(data.tags || []),
        metadata: safeJsonStringify(data.metadata || {}),
      };

      const keys = Object.keys(serializedData);
      const values = Object.values(serializedData);
      const placeholders = keys.map(() => "?").join(", ");
      const query = `INSERT INTO memories (${keys.join(", ")}) VALUES (${placeholders}) RETURNING *`;
      const stmt = db.prepare(query);
      const result = stmt.get(...values) as MemoryRow;
      return result;
    } catch (error) {
      throw new Error(`Failed to create memory: ${error}`);
    }
  }

  async createMany(data: CreateMemoryInput[]): Promise<MemoryRow[]> {
    if (!data || data.length === 0) return [];

    try {
      const serializedData = data.map((item) => ({
        ...item,
        embedding: safeJsonStringify(item.embedding),
        tags: safeJsonStringify(item.tags || []),
        metadata: safeJsonStringify(item.metadata || {}),
      }));

      const keys = Object.keys(serializedData[0]);
      const placeholders = keys.map(() => "?").join(", ");
      const query = `INSERT INTO memories (${keys.join(", ")}) VALUES (${placeholders}) RETURNING *`;
      const insertStmt = db.prepare(query);
      const insertManyTx = db.transaction((items) => {
        const results: MemoryRow[] = [];
        for (const item of items) {
          const values = Object.values(item);
          results.push(insertStmt.get(...values) as MemoryRow);
        }
        return results;
      });
      return insertManyTx(serializedData);
    } catch (error) {
      throw new Error(`Failed to bulk create memories: ${error}`);
    }
  }

  async update(id: EntityId, data: UpdateMemoryInput): Promise<MemoryRow> {
    try {
      const serializedData = {
        ...data,
        embedding: data.embedding
          ? safeJsonStringify(data.embedding)
          : undefined,
        tags: data.tags ? safeJsonStringify(data.tags) : undefined,
        metadata: data.metadata ? safeJsonStringify(data.metadata) : undefined,
      };

      // Remove undefined values
      const cleanedData = Object.entries(serializedData).reduce(
        (acc, [key, value]) => {
          if (value !== undefined) {
            acc[key] = value;
          }
          return acc;
        },
        {} as Record<string, any>
      );

      const keys = Object.keys(cleanedData);
      const values = Object.values(cleanedData);
      const setClause = keys.map((key) => `${key} = ?`).join(", ");
      const query = `UPDATE memories SET ${setClause} WHERE id = ? RETURNING *`;
      const stmt = db.prepare(query);
      const result = stmt.get(...values, id) as MemoryRow;
      return result;
    } catch (error) {
      throw new Error(`Failed to update memory: ${error}`);
    }
  }
}
